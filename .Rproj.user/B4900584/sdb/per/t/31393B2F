{
    "collab_server" : "",
    "contents" : "#' RDD plots\n#'\n#' A function to create RDD plots.\n#'\n#' @param x Forcing variable\n#' @param y Dependent variable\n#' @param c Cutoff\n#' @param p Polynomial order\n#' @param numbinl Bins to the left\n#' @param numbinr Bins to the right\n#' @param binselect Method to select bins\n#' @param x.lim Limits on X axis\n#' @param y.lim Limits on Y axis\n#' @param lowerend Lower end\n#' @param upperend Upper end\n#' @param scale Scale\n#' @param scalel Scale to the left\n#' @param scaler Scale to the right\n#' @param ... Further arguments\n#'\n#' @import ggplot2\n#' @importFrom stats complete.cases lm quantile var\n#'\n#' @return A ggplot2 object\n#'\n#' @export\n\nrd_plot <- function(x, y, c = 0, p = 2, numbinl = NULL, numbinr = NULL, binselect = \"esmv\",\n                   x.lim = NULL, y.lim = NULL, lowerend = NULL, upperend = NULL, scale = 1, scalel = 1,scaler = 1, ...) {\n\n  call <- match.call()\n  if(!is.null(x.lim)) na.ok <- stats::complete.cases(x) & stats::complete.cases(y) & x > x.lim[1] & x < x.lim[2]\n  else na.ok <- stats::complete.cases(x) & stats::complete.cases(y)\n\n  x <- x[na.ok]\n  y <- y[na.ok]\n\n  if (is.null(lowerend)) {\n    lowerend = min(x)\n  }\n  if (is.null(upperend)) {\n    upperend = max(x)\n  }\n  x_low = lowerend\n  x_upp = upperend\n\n  size=sum(x>=x_low & x<=x_upp)\n  y=y[x>=x_low & x<=x_upp]\n  x=x[x>=x_low & x<=x_upp]\n\n  x_l = x[x<c]; x_r = x[x>=c]\n  y_l = y[x<c];\ty_r = y[x>=c]\n  x.min = min(x);\tx.max = max(x)\n  range_l = max(x_l) - min(x_l)\n  n_l = length(x_l)\n  range_r = max(x_r) - min(x_r)\n  n_r = length(x_r)\n  n = n_l + n_r\n  meth=\"es\"\n  #####********************* ERRORS\n  exit=0\n  if (c<=x.min | c>=x.max){\n    print(\"c should be set within the range of x\")\n    exit = 1\n  }\n\n  if (p<=0 ){\n    print(\"p should be a positive number\")\n    exit = 1\n  }\n\n  if (scale<=0 |scalel<=0 |scaler<=0){\n    print(\"scale should be a positive number\")\n    exit = 1\n  }\n\n  p_ceiling = ceiling(p)/p\n\n  if (p_ceiling!=1) {\n    print(\"p should be an integer number\")\n    exit = 1\n  }\n\n  if (exit>0) {\n    stop()\n  }\n\n  p1 = p+1\n  compute =0\n\n  rp_l = matrix(NA,n_l,p+1);  rp_r = matrix(NA,n_r,p+1)\n  for (j in 1:p1) {\n    rp_l[,j] = x_l^(j-1)\n    rp_r[,j] = x_r^(j-1)\n  }\n  gamma_p1_l = stats::lm(y_l~rp_l-1)$coeff\n  gamma_p1_r = stats::lm(y_r~rp_r-1)$coeff\n\n  mu0_p1_l = rp_l%*%gamma_p1_l;\tmu0_p1_r = rp_r%*%gamma_p1_r\n\n  J_star_orig=c(numbinl, numbinr)\n\n  y_l.sq = y_l^2\n  y_r.sq = y_r^2\n  gamma_p2_l = stats::lm(y_l.sq~rp_l-1)$coeff\n  gamma_p2_r = stats::lm(y_r.sq~rp_r-1)$coeff\n\n  ### Bias w/sample\n\n  drp_l = matrix(NA,n_l,p);\tdrp_r = matrix(NA,n_r,p)\n  for (j in 1:p) {\n    drp_l[,j] = j*x_l^(j-1)\n    drp_r[,j] = j*x_r^(j-1)\n  }\n  mu1_hat_l = drp_l%*%(gamma_p1_l[2:p1])\n  mu1_hat_r = drp_r%*%(gamma_p1_r[2:p1])\n\n  ######################### ES\n  ind.l = order(x_l); ind.r = order(x_r)\n  x.i.l = x_l[ind.l]; x.i.r = x_r[ind.r]\n  y.i.l = y_l[ind.l]; y.i.r = y_r[ind.r]\n\n  dxi.l=(x.i.l[2:length(x.i.l)]-x.i.l[1:(length(x.i.l)-1)])\n  dxi.r=(x.i.r[2:length(x.i.r)]-x.i.r[1:(length(x.i.r)-1)])\n  dyi.l=(y.i.l[2:length(y.i.l)]-y.i.l[1:(length(y.i.l)-1)])\n  dyi.r=(y.i.r[2:length(y.i.r)]-y.i.r[1:(length(y.i.r)-1)])\n\n  x.bar.i.l = (x.i.l[2:length(x.i.l)]+x.i.l[1:(length(x.i.l)-1)])/2\n  x.bar.i.r = (x.i.r[2:length(x.i.r)]+x.i.r[1:(length(x.i.r)-1)])/2\n  rp.i_l  = matrix(NA,n_l-1,p+1); rp.i_r= matrix(NA,n_r-1,p+1)\n  drp.i_l = matrix(NA,n_l-1,p); drp.i_r = matrix(NA,n_r-1,p)\n\n  for (j in 1:p1) {\n    rp.i_l[,j] = x.bar.i.l^(j-1)\n    rp.i_r[,j] = x.bar.i.r^(j-1)\n  }\n\n  for (j in 1:p) {\n    drp.i_l[,j] = j*x.bar.i.l^(j-1)\n    drp.i_r[,j] = j*x.bar.i.r^(j-1)\n  }\n\n  mu0.i_hat_l = rp.i_l%*%gamma_p1_l;  mu0.i_hat_r = rp.i_r%*%gamma_p1_r\n  mu2.i_hat_l = rp.i_l%*%gamma_p2_l;  mu2.i_hat_r = rp.i_r%*%gamma_p2_r\n\n  mu0_hat_l = rp_l%*%gamma_p1_l;  mu0_hat_r = rp_r%*%gamma_p1_r\n  mu2_hat_l = rp_l%*%gamma_p2_l;  mu2_hat_r = rp_r%*%gamma_p2_r\n\n  mu1.i_hat_l = drp.i_l%*%(gamma_p1_l[2:p1]);  mu1.i_hat_r = drp.i_r%*%(gamma_p1_r[2:p1])\n\n  sigma2_hat_l.bar = mu2.i_hat_l - mu0.i_hat_l^2\n  sigma2_hat_r.bar = mu2.i_hat_r - mu0.i_hat_r^2\n\n  sigma2_hat_l = mu2_hat_l - mu0_hat_l^2\n  sigma2_hat_r = mu2_hat_r - mu0_hat_r^2\n\n  J.fun = function(B,V) {ceiling((((2*B)/V)*n)^(1/3))}\n  var.y_l = var(y_l)\n  var.y_r = var(y_r)\n\n  B.es.hat.dw = c( ((c-x.min)^2/(12*n))*sum(mu1_hat_l^2),((x.max-c)^2/(12*n))*sum(mu1_hat_r^2))\n  V.es.hat.dw = c((0.5/(c-x.min))*sum(dxi.l*dyi.l^2),(0.5/(x.max-c))*sum(dxi.r*dyi.r^2))\n  V.es.chk.dw = c((1/(c-x.min))*sum(dxi.l*sigma2_hat_l.bar),(1/(x.max-c))*sum(dxi.r*sigma2_hat_r.bar))\n  J.es.hat.dw = J.fun(B.es.hat.dw, V.es.hat.dw)\n  J.es.chk.dw = J.fun(B.es.hat.dw, V.es.chk.dw)\n\n  B.qs.hat.dw = c((n_l^2/(24*n))*sum(dxi.l^2*mu1.i_hat_l^2), (n_r^2/(24*n))*sum(dxi.r^2*mu1.i_hat_r^2))\n  V.qs.hat.dw = c((1/(2*n_l))*sum(dyi.l^2),(1/(2*n_r))*sum(dyi.r^2))\n  V.qs.chk.dw = c((1/n_l)*sum(sigma2_hat_l), (1/n_r)*sum(sigma2_hat_r))\n  J.qs.hat.dw = J.fun(B.qs.hat.dw, V.qs.hat.dw)\n  J.qs.chk.dw = J.fun(B.qs.hat.dw, V.qs.chk.dw)\n\n  J.es.hat.mv  = c(ceiling((var.y_l/V.es.hat.dw[1])*(n/log(n)^2)), ceiling((var.y_r/V.es.hat.dw[2])*(n/log(n)^2)))\n  J.es.chk.mv  = c(ceiling((var.y_l/V.es.chk.dw[1])*(n/log(n)^2)), ceiling((var.y_r/V.es.chk.dw[2])*(n/log(n)^2)))\n  J.qs.hat.mv  = c(ceiling((var.y_l/V.qs.hat.dw[1])*(n/log(n)^2)), ceiling((var.y_r/V.qs.hat.dw[2])*(n/log(n)^2)))\n  J.qs.chk.mv  = c(ceiling((var.y_l/V.qs.chk.dw[1])*(n/log(n)^2)), ceiling((var.y_r/V.qs.chk.dw[2])*(n/log(n)^2)))\n\n  if (binselect==\"es\") {\n    J_star_orig = J.es.hat.dw\n    meth=\"es\"\n    binselect_type=\"IMSE-optimal evenly-spaced method using spacings estimators\"\n    J_IMSE = J.es.hat.dw\n    J_MV   = J.es.hat.mv\n  }\n\n  if (binselect==\"espr\") {\n    J_star_orig = J.es.chk.dw\n    meth=\"es\"\n    binselect_type=\"IMSE-optimal evenly-spaced method using polynomial regression\"\n    J_IMSE = J.es.chk.dw\n    J_MV   = J.es.chk.mv\n  }\n\n  if (binselect==\"esmv\" ) {\n    J_star_orig = J.es.hat.mv\n    meth=\"es\"\n    binselect_type=\"mimicking variance evenly-spaced method using spacings estimators\"\n    J_IMSE = J.es.hat.dw\n    J_MV   = J.es.hat.mv\n  }\n\n  if (binselect==\"esmvpr\" ) {\n    J_star_orig = J.es.chk.mv\n    meth=\"es\"\n    binselect_type=\"mimicking variance evenly-spaced method using polynomial regression\"\n    J_IMSE = J.es.chk.dw\n    J_MV   = J.es.chk.mv\n  }\n\n\n  if (binselect==\"qs\" ) {\n    J_star_orig = J.qs.hat.dw\n    meth=\"qs\"\n    binselect_type=\"IMSE-optimal quantile-spaced method using spacings estimators\"\n    J_IMSE = J.qs.hat.dw\n    J_MV   = J.qs.hat.mv\n  }\n\n  if (binselect==\"qspr\" ) {\n    J_star_orig = J.qs.chk.dw\n    meth=\"qs\"\n    binselect_type=\"IMSE-optimal quantile-spaced method using polynomial regression\"\n    J_IMSE = J.qs.chk.dw\n    J_MV   = J.qs.chk.mv\n  }\n  if (binselect==\"qsmv\" ) {\n    J_star_orig = J.qs.hat.mv\n    meth=\"qs\"\n    binselect_type=\"mimicking variance quantile-spaced method using spacings estimators\"\n    J_IMSE = J.qs.hat.dw\n    J_MV   = J.qs.hat.mv\n  }\n\n\n  if (binselect==\"qsmvpr\" ) {\n    J_star_orig = J.qs.chk.mv\n    meth=\"qs\"\n    binselect_type=\"mimicking variance quantile-spaced method using polynomial regression\"\n    J_IMSE = J.qs.chk.dw\n    J_MV   = J.qs.chk.mv\n  }\n\n  if (scale>1 & scalel==1 & scaler==1){\n    scalel=scaler=scale\n  }\n\n  J_star_l = scalel*J_star_orig[1]\n  J_star_r = scaler*J_star_orig[2]\n\n  if (!is.null(numbinl)&!is.null(numbinr)) {\n    J_star_l = numbinl\n    J_star_r = numbinr\n    binselect_type=\"manually evenly spaced\"\n  }\n\n\n  scale_l = J_star_l / J_IMSE[1]\n  scale_r = J_star_r / J_IMSE[2]\n\n  bin_x_l = rep(0,length(x_l)); bin_x_r = rep(0,length(x_r))\n  jump_l = range_l/J_star_l;jump_r = range_r/J_star_r;\n\n  if (meth==\"es\") {\n    jumps_l=seq(min(x_l),max(x_l),jump_l)\n    jumps_r=seq(min(x_r),max(x_r),jump_r)\n    #binselect_type=\"Evenly-Spaced\"\n  }\n  else if (meth==\"qs\") {\n    jumps_l=quantile(x_l,probs=seq(0,1,1/J_star_l))\n    jumps_r=quantile(x_r,probs=seq(0,1,1/J_star_r))\n    # binselect_type=\"Quantile-Spaced\"\n  }\n\n  for (k in 1:(J_star_l-1)) {\n    bin_x_l[x_l>=jumps_l[k] & x_l<jumps_l[k+1]] = -J_star_l+k-1\n  }\n  bin_x_l[x_l>=jumps_l[(J_star_l)]] = -1\n\n  for (k in 1:(J_star_r-1)) {\n    bin_x_r[x_r>=jumps_r[k] & x_r<jumps_r[k+1]] = k\n  }\n  bin_x_r[x_r>=jumps_r[(J_star_r)]] = J_star_r\n\n  bin_xlmean=bin_ylmean=rep(0,J_star_l)\n  bin_xrmean=bin_yrmean=rep(0,J_star_r)\n  for (k in 1:(J_star_l)) {\n    bin_xlmean[k]=mean(c(jumps_l[k],jumps_l[k+1]))\n    #bin_xlmean[k]=mean(x_l[bin_x_l==-k])\n    bin_ylmean[J_star_l-k+1]=mean(y_l[bin_x_l==-k])\n  }\n  for (k in 1:(J_star_r)) {\n    bin_xrmean[k]=mean(c(jumps_r[k],jumps_r[k+1]))\n    #bin_xrmean[k]=mean(x_r[bin_x_r==k])\n    bin_yrmean[k]=mean(y_r[bin_x_r==k])\n  }\n\n  bin_x=c(bin_x_l,bin_x_r)\n  bin_xmean=c(bin_xlmean,bin_xrmean)\n  bin_ymean=c(bin_ylmean,bin_yrmean)\n  x_sup = c(x_l, x_r)\n  #y_hat = c(mu0_p1_l, mu0_p1_r)\n\n  if (is.null(x.lim)){\n    x.lim=c(min(x_l),max(x_r))\n  }\n\n  if (is.null(y.lim)){\n    y.lim=c(min(c(y_l,y_r)),max(c(y_l,y_r)))\n  }\n\n  treat <- 0\n  dados <- data.frame(x = bin_xmean[order(bin_xmean)], y = bin_ymean[order(bin_xmean)], treat = treat)\n  dados$treat[dados$x >= c] <- 1\n\n  ggplot2::ggplot(dados, aes(x, y, group = factor(treat))) + ggplot2::stat_smooth(method = \"lm\", formula = y ~ x + I(x^2), se = F, colour = \"black\", alpha = 0.2, size = .82) +\n    ggplot2::geom_point(size = 1.8, color = \"gray5\") + ggplot2::geom_vline(xintercept = c, linetype = 2, size = 0.4) + ggplot2::scale_y_continuous(expand = c(0, 0), limits = y.lim) +\n    ggplot2::scale_x_continuous(expand = c(0, 0))\n}\n",
    "created" : 1475956625647.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4276217833",
    "id" : "31393B2F",
    "lastKnownWriteTime" : 1475958933,
    "last_content_update" : 1475958933220,
    "path" : "C:/Users/User/Google Drive/R/Pacotes/fmeireles/R/rd_plot.R",
    "project_path" : "R/rd_plot.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}